; Optimized PHP-FPM pool configuration for WordPress
[www]

; Listen on TCP port 9000 (matches the base WordPress FPM image and Dockerfile EXPOSE)
listen = 9000

; Allow connections from anywhere in the container network (rely on Docker network isolation)
; If you front this with a local web server in the same container, you can restrict to 127.0.0.1.
;listen.allowed_clients = 127.0.0.1

; Increase backlog to better handle short bursts of traffic
listen.backlog = 512

; Process manager tuning for ~1–2GB container and 2 vCPUs
; If you raise container memory to 2–4GB, you can safely increase pm.max_children to 16
pm = dynamic
pm.max_children = 12
pm.start_servers = 4
pm.min_spare_servers = 2
pm.max_spare_servers = 8
pm.max_requests = 500

; Timeouts
; Hard kill for very long-running requests (lower than php.ini max_execution_time=300)
request_terminate_timeout = 120s

; Log stack traces for very slow requests
request_slowlog_timeout = 10s
slowlog = /proc/self/fd/2

; Catch worker stdout/stderr and send to main FPM log stream
catch_workers_output = yes

; Status and ping paths (can be wired into healthchecks / monitoring)
pm.status_path = /fpm-status
ping.path = /fpm-ping
ping.response = pong

; Logging to container stdout/stderr so Docker can capture it
access.log = /proc/self/fd/1
access.format = "%R - %u %t \"%m %r%Q%q\" %s %f %{mili}dms %{kilo}Mkb %C%%"

; Ensure PHP error logging is on and goes to stderr
php_admin_flag[log_errors] = on
php_admin_value[error_log] = /proc/self/fd/2

; Enforce memory_limit at pool level (mirrors php.ini)
php_admin_value[memory_limit] = 512M
